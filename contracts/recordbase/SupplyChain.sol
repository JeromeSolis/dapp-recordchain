pragma solidity ^0.4.24;
// Define a contract 'Supplychain'
contract SupplyChain {

  // Define 'owner'
  address owner;

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint  upc;

  // Define a variable called 'sku' for Stock Keeping Unit (SKU)
  uint  sku;

  // Define a public mapping 'items' that maps the UPC to an Item.
  mapping (uint => Item) items;

  // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash, 
  // that track its journey through the supply chain -- to be sent from DApp.
  mapping (uint => string[]) itemsHistory;
  
  // Define enum 'State' with the following values:
  enum State 
  { 
    Pitched,    // 0
    Signed,     // 1
    Recorded,   // 2
    Produced,   // 3
    ForSale,    // 4
    Purchased,  // 5
    }

  State constant defaultState = State.Pitched;

  // Define a struct 'Item' with the following fields:
  struct Item {
    uint    sku;  // Stock Keeping Unit (SKU)
    uint    upc; // Universal Product Code (UPC), generated by the Label, goes on the package, can be verified by the Consumer
    address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 6 stages
    address labelID; // Metamask-Ethereum address of the Label
    string  labelName; // Label Name
    string  labelInformation;  // Label Information
    uint    albumID;  // Album ID potentially a combination of upc + sku
    string  albumTitle // Album Title
    string  albumTracks // Tracks of the album
    string  albumStyle; // Musical style attribute
    string  albumNotes; // Album Notes
    uint    albumPrice; // Album Price
    State   itemState;  // Album State as represented in the enum above
    address artistID;  // Metamask-Ethereum address of the Artist
    string  artistName;
    address consumerID; // Metamask-Ethereum address of the Consumer
  }

  // Define 6 events with the same 6 state values and accept 'upc' as input argument
  event Pitched(uint upc);
  event Signed(uint upc);
  event Recorded(uint upc);
  event Produced(uint upc);
  event ForSale(uint upc);
  event Purchased(uint upc);

  // Define a modifer that checks to see if msg.sender == owner of the contract
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address); 
    _;
  }

  // Define a modifier that checks if the paid amount is sufficient to cover the price
  modifier paidEnough(uint _price) { 
    require(msg.value >= _price); 
    _;
  }
  
  // Define a modifier that checks the price and refunds the remaining balance
  modifier checkValue(uint _upc) {
    _;
    uint _price = items[_upc].productPrice;
    uint amountToReturn = msg.value - _price;
    items[_upc].consumerID.transfer(amountToReturn);
  }

  // Define a modifier that checks if an item.state of a upc is Pitched
  modifier pitched(uint _upc) {
    require(items[_upc].itemState == State.Pitched);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Signed
  modifier signed(uint _upc) {
    require(items[_upc].itemState == State.Signed);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Recorded
  modifier recorded(uint _upc) {
    require(items[_upc].itemState == State.Recorded);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Produced
  modifier produced(uint _upc) {
    require(items[_upc].itemState == State.Produced);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is ForSale
  modifier forSale(uint _upc) {
    require(items[_upc].itemState == State.ForSale);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Purchased
  modifier purchased(uint _upc) {
    require(items[_upc].itemState == State.Purchased);
    _;
  }

  // In the constructor set 'owner' to the address that instantiated the contract
  // and set 'sku' to 1
  // and set 'upc' to 1
  constructor() public payable {
    owner = msg.sender;
    sku = 1;
    upc = 1;
  }

  // Define a function 'kill' if required
  function kill() public {
    if (msg.sender == owner) {
      selfdestruct(owner);
    }
  }

  // Define a function 'meetLabel' that allows a artist to mark an album 'Pitched' and start discussing with potential labels
function meetLabel(uint _upc, address _originArtistID, string _originArtistName, string _albumTitle, string _albumTracks, string _albumStyle, string  _albumNotes) public onlyArtist()  
  {
    // Add the new item as part of Harvest
    items[_upc].artistID = _originArtistID;
    items[_upc].artistName = _originArtistName;
    items[_upc].albumID = `${_upc}_${sku}`;
    items[_upc].albumTitle = _albumTitle;
    items[_upc].albumTracks = _albumTracks;
    items[_upc].albumStyle = _albumStyle;
    items[_upc].albumNotes = _albumNotes;
    items[_upc].ownerID = items[_upc].artistID;
    items[_upc].itemState = State.Pitched;
    // Increment sku
    sku = sku + 1;
    // Emit the appropriate event
    emit Pitched(_upc); 
  }

  // Define a function 'signContract' that allows a artist to engage in a contractual relationship with a label and mark an item 'Signed', effectively transfering the ownership to the chosen label
  // Call modifier to check if upc has passed previous supply chain stage
  // Call modifier to verify caller of this function
  function signContract(uint _upc, address _originLabelID, string _originLabelName, string _originLabelInformation) public pitched(_upc) onlyArtist() verifyCaller(items[_upc].ownerID)
  {
    // Update the appropriate fields
    items[_upc].labelID = _originlabelID;
    items[_upc].labelName = _originLabelName;
    items[_upc].labelInformation = _originLabelInformation;    
    items[_upc].itemState = State.Signed;
    items[_upc].ownerID = items[_upc].labelID;
    // Emit the appropriate event
    emit Signed(_upc);
  }

  // Define a function 'recordAlbum' that allows a label to mark an album 'Recorded'
  // Call modifier to check if upc has passed previous supply chain stage
  // Call modifier to verify caller of this function
  function recordAlbum(uint _upc) public signed(_upc) onlyLabel() verifyCaller(items[_upc].ownerID)   
  {
    // Update the appropriate fields
    items[_upc].itemState = State.Recorded;
    // Emit the appropriate event
    emit Recorded(_upc);
  }

  // Define a function 'mixAlbum' that allows a farmer to mark an item 'Produced'
  // Call modifier to check if upc has passed previous supply chain stage
  // Call modifier to verify caller of this function
  function mixAlbum(uint _upc) public recorded(_upc) onlyLabel() verifyCaller(items[_upc].ownerID)  
  {
    // Update the appropriate fields
    items[_upc].itemState = State.Produced
    // Emit the appropriate event
    emit Produced(_upc);
  }

  // Define a function 'sellAlbum' that allows a label to mark an album 'ForSale'
  // Call modifier to check if upc has passed previous supply chain stage
  // Call modifier to verify caller of this function
  function sellAlbum(uint _upc, uint _price) public produced(_upc) onlyLabel() verifyCaller(items[_upc].labelID)  
  {
    // Update the appropriate fields
    items[_upc].albumPrice = _price;
    items[_upc].itemState = State.ForSale
    // Emit the appropriate event
    emit ForSale(_upc);
  }

  // Define a function 'buyAlbum' that allows the consumer to mark an item 'Purchased'
  // Use the above defined modifiers to check if the item is ForSale for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  // Call modifier to check if upc has passed previous supply chain stage
  // Call modifer to check if buyer has paid enough
  // Call modifer to send any excess ether back to buyer
  function buyAlbum(uint _upc) forSale(_upc) public payable forSale(_upc) paidEnough(items[_upc].albumPrice) checkValue(items[_upc].albumPrice) onlyConsumer()
    {
    // Update the appropriate fields - ownerID, distributorID, itemState
    address buyer = msg.sender;
    items[_upc].State = State.Purchased;
    items[_upc].consumerID = buyer;
    items[_upc].ownerID = items[_upc].consumerID;
    // Transfer money to farmer
    uint price = items[_upc].albumPrice;
    items[_upc].labelID.transfer(price);
    // emit the appropriate event
    emit Purchased(_upc)
  }

  // Define a function 'fetchItemBufferOne' that fetches the data
  function fetchItemBufferOne(uint _upc) public view returns 
  (
  uint    itemSKU,
  uint    itemUPC,
  address ownerID,
  address originArtistID,
  string  originArtistName,
  string  albumTitle,
  string  albumTracks,
  string  albumStyle,
  string  albumNotes,
  ) 
  {
    // Assign values to the 9 parameters
    itemSKU = items[_upc].sku;
    itemUPC = items[_upc].upc;
    ownerID = items[_upc].ownerID
    originArtistID = items[_upc].artistID;
    originArtistName = items[_upc].artistName;
    albumTitle = items[_upc].albumTitle;
    albumTracks = items[_upc].albumTracks;
    albumStyle = items[_upc].albumStyle;
    albumNotes = items[_upc].albumNotes;
      
    return 
    (
    itemSKU,
    itemUPC,
    ownerID,
    originArtistID,
    originArtistName,
    albumTitle,
    albumTracks,
    albumStyle,
    albumNotes
    );
  }

  // Define a function 'fetchItemBufferTwo' that fetches the data
  function fetchItemBufferTwo(uint _upc) public view returns 
  (
  uint    itemSKU,
  uint    itemUPC,
  uint    albumID,
  uint    albumPrice,
  uint    itemState,
  string  labelName,
  string  labelInformation,
  address labelID,
  address consumerID
  ) 
  {
    // Assign values to the 9 parameters
    itemSKU = items[_upc].sku;
    itemUPC = items[_upc].upc;
    albumID = items[_upc].albumID;
    albumPrice = items[_upc].albumPrice;
    itemState = items[_upc].itemState;
    labelID = items[_upc].labelID;
    labelName = items[_upc].labelName;
    labelInformation = items[_upc].labelInformation;
    consumerID = items[_upc].consumerID;
    
    return 
    (
    itemSKU,
    itemUPC,
    albumID,
    albumPrice,
    itemState,
    labelID,
    labelName,
    labelInformation,
    consumerID
    );
  }
}
