// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require('SupplyChain')
var ArtistRole = artifacts.require('ArtistRole')

contract('SupplyChain', function(accounts) {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    var sku = 1
    var upc = 1
    const ownerID = accounts[0]
    const originArtistID = accounts[1]
    const originArtistName = "The John Does"
    const albumTitle = "To Test Or Not To Test"
    const albumStyle = "Buggy Music"
    const albumTracks = "1. One 2. Two 3. Three"
    const albumNotes = "Fully Remastered"
    var albumID = sku + upc
    const albumPrice = web3.toWei(1, "ether")
    var itemState = 0
    const labelID = accounts[2]
    const labelName = "SemiPro Records"
    const labelInformation = "It could be worst."
    const consumerID = accounts[3]
    const emptyAddress = '0x00000000000000000000000000000000000000'

    ///Available Accounts
    ///==================
    // (0) 0x627306090abab3a6e1400e9345bc60c78a8bef57
    // (1) 0xf17f52151ebef6c7334fad080c5704d77216b732
    // (2) 0xc5fdf4076b8f3a5357c5e395ab970b5b54098fef
    // (3) 0x821aea9a577a9b44299b9c15c88cf3087f3b5544
    // (4) 0x0d1d4e623d10f9fba5db95830f7d3839406c6af2
    // (5) 0x2932b7a2355d6fecc4b5c0b6bd44cc31df247a2e
    // (6) 0x2191ef87e392377ec08e7c08eb105ef5448eced5
    // (7) 0x0f4f2ac550a1b4e2280d04c21cea7ebd822934b5
    // (8) 0x6330a553fc93768f612722bb8c2ec78ac90b3bbc
    // (9) 0x5aeda56215b167893e80b4fe645ba6d5bab767de

    console.log("ganache-cli accounts used here...")
    console.log("Contract Owner: accounts[0] ", accounts[0])
    console.log("Artist: accounts[1] ", accounts[1])
    console.log("Label: accounts[2] ", accounts[2])
    console.log("COnsumer: accounts[3] ", accounts[3])

    // 1st Test
    it("Testing smart contract function meetLabel() that allows an artist to pitch an album to a label", async() => {
        const supplyChain = await SupplyChain.deployed()
        await supplyChain.addArtist(originArtistID)
        
        // Declare and Initialize a variable for event
        var eventEmitted = false
        
        // Watch the emitted event Pitched()
        var event = supplyChain.Pitched()
        await event.watch((err, res) => {
            eventEmitted = true
        })

        // Mark an item as Pitched by calling function meetLabel()
        await supplyChain.meetLabel.sendTransaction(upc, originArtistID, originArtistName, albumTitle, albumTracks, albumStyle, albumNotes, {from: originArtistID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU')
        assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC')
        assert.equal(resultBufferOne[2], originArtistID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], originArtistID, 'Error: Missing or Invalid originArtistID')
        assert.equal(resultBufferOne[4], originArtistName, 'Error: Missing or Invalid originArtistName')
        assert.equal(resultBufferOne[5], albumTitle, 'Error: Missing or Invalid albumTitle')
        assert.equal(resultBufferOne[6], albumTracks, 'Error: Missing or Invalid albumTracks')
        assert.equal(resultBufferOne[7], albumStyle, 'Error: Missing or Invalid albumStyle')
        assert.equal(resultBufferOne[8], albumNotes, 'Error: Missing or Invalid albumNotes')
        assert.equal(resultBufferTwo[4], 0, 'Error: Invalid item State')
        assert.equal(resultBufferTwo[2], albumID, 'Error: Invalid albumID')
        assert.equal(eventEmitted, true, 'Invalid event emitted')        
    })    

    // 2nd Test
    it("Testing smart contract function signContract() that allows an Artist to establish a contractual relationship with a record label", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false        
        
        // Watch the emitted event Processed()
        var event = supplyChain.Signed()
        await event.watch((err, res) => {
            eventEmitted = true
        })

        // Mark an item as Processed by calling function processtItem()
        await supplyChain.signContract.sendTransaction(upc, labelID, labelName, labelInformation, {from: originArtistID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferOne[2], labelID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferTwo[5], labelID, 'Error: Missing or Invalid labelID')
        assert.equal(resultBufferTwo[6], labelName, 'Error: Missing or Invalid labelName')
        assert.equal(resultBufferTwo[7], labelInformation, 'Error: Missing or Invalid labelInformation')
        assert.equal(resultBufferTwo[4], 1, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 3rd Test
    it("Testing smart contract function recordAlbum() that allows a label to record an album", async() => {
        const supplyChain = await SupplyChain.deployed()
        await supplyChain.addLabel(labelID)
        
        // Declare and Initialize a variable for event
        var eventEmitted = false        
        
        // Watch the emitted event Recorded()
        var event = supplyChain.Recorded()
        await event.watch((err, res) => {
            eventEmitted = true
        })

        // Mark an item as Recorded by calling function recordAlbum()
        await supplyChain.recordAlbum.sendTransaction(upc, {from: labelID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc) 

        // Verify the result set
        assert.equal(resultBufferTwo[4], 2, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 4th Test
    it("Testing smart contract function mixAlbum() that allows a label to mix a recorded album", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false
        
        // Watch the emitted event Produced()
        var event = supplyChain.Produced()
        await event.watch((err, res) => {
            eventEmitted = true
        })

        // Mark an item as Produced by calling function mixAlbum()
        await supplyChain.mixAlbum.sendTransaction(upc, {from: labelID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferTwo[4], 3, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 5th Test
    it("Testing smart contract function sellAlbum() that allows a label to put an album for sale", async() => {
        const supplyChain = await SupplyChain.deployed()
        
        // Declare and Initialize a variable for event
        var eventEmitted = false
        
        // Watch the emitted event ForSale()
        var event = supplyChain.ForSale()
        await event.watch((err, res) => {
            eventEmitted = true
        })

        // Mark an item as ForSale by calling function sellAlbum()
        await supplyChain.sellAlbum.sendTransaction(upc, albumPrice, {from: labelID})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferTwo[3], albumPrice, 'Error: Missing or Invalid albumPrice')
        assert.equal(resultBufferTwo[4], 4, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 6th Test
    it("Testing smart contract function buyAlbum() that allows a consumer to buy an album", async() => {
        const supplyChain = await SupplyChain.deployed()
        await supplyChain.addConsumer(consumerID)

        // Declare and Initialize a variable for event
        var eventEmitted = false
        
        // Watch the emitted event Shipped()
        var event = supplyChain.Purchased()
        await event.watch((err, res) => {
            eventEmitted = true
        })

        // Mark an item as Purchased by calling function buyAlbum()
        const amountPayable = web3.toWei(1.1, "ether")
        await supplyChain.buyAlbum.sendTransaction(upc, {from: consumerID, value: amountPayable})

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc)
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc)

        // Verify the result set
        assert.equal(resultBufferTwo[8], consumerID, 'Error: Missing or Invalid consumerID')
        assert.equal(resultBufferOne[2], consumerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferTwo[4], 5, 'Error: Invalid item State')
        assert.equal(eventEmitted, true, 'Invalid event emitted')
    })    

    // 7th Test
    it("Testing smart contract function fetchItemBufferOne() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferOne = await supplyChain.fetchItemBufferOne.call(upc, {from: ownerID})
        
        // Verify the result set:
        assert.equal(resultBufferOne[0], sku, 'Error: Missing or Invalid sku')
        assert.equal(resultBufferOne[1], upc, 'Error: Missing or Invalid upc')
        assert.equal(resultBufferOne[2], consumerID, 'Error: Missing or Invalid ownerID')
        assert.equal(resultBufferOne[3], originArtistID, 'Error: Missing or Invalid originArtistID')
        assert.equal(resultBufferOne[4], originArtistName, 'Error: Missing or Invalid originArtistName')
        assert.equal(resultBufferOne[5], albumTitle, 'Error: Missing or Invalid albumTitle')
        assert.equal(resultBufferOne[6], albumTracks, 'Error: Missing or Invalid albumTracks')
        assert.equal(resultBufferOne[7], albumStyle, 'Error: Missing or Invalid albumStyle')
        assert.equal(resultBufferOne[8], albumNotes, 'Error: Missing or Invalid albumNotes')
    })

    // 8th Test
    it("Testing smart contract function fetchItemBufferTwo() that allows anyone to fetch item details from blockchain", async() => {
        const supplyChain = await SupplyChain.deployed()

        // Retrieve the just now saved item from blockchain by calling function fetchItem()
        const resultBufferTwo = await supplyChain.fetchItemBufferTwo.call(upc, {from: ownerID})
        
        // Verify the result set:
        assert.equal(resultBufferTwo[0], sku, 'Error: Missing or Invalid sku')
        assert.equal(resultBufferTwo[1], upc, 'Error: Missing or Invalid upc')
        assert.equal(resultBufferTwo[2], albumID, 'Error: Missing or Invalid albumID')
        assert.equal(resultBufferTwo[3], albumPrice, 'Error: Missing or Invalid albumPrice')
        assert.equal(resultBufferTwo[4], 5, 'Error: Missing or Invalid itemState')
        assert.equal(resultBufferTwo[5], labelID, 'Error: Missing or Invalid labelID')
        assert.equal(resultBufferTwo[6], labelName, 'Error: Missing or Invalid labelName')
        assert.equal(resultBufferTwo[7], labelInformation, 'Error: Missing or Invalid labelInformation')
        assert.equal(resultBufferTwo[8], consumerID, 'Error: Missing or Invalid albumPrice')
    })

});

